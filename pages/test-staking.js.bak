import React, { useState, useEffect } from 'react';
import { useWallet, useConnection } from '@solana/wallet-adapter-react';
import { WalletMultiButton } from '@solana/wallet-adapter-react-ui';
import { Transaction } from '@solana/web3.js';
import Layout from '../components/Layout';
import { api } from '../services/api';
import TokenAccountInitializer from '../components/staking/TokenAccountInitializer';
import EnhancedStakingDashboard from '../components/staking/EnhancedStakingDashboard';

/**
 * 개선된 스테이킹 테스트 페이지
 */
export default function TestStaking() {
  const wallet = useWallet();
  const { connection } = useConnection();
  const [nfts, setNfts] = useState([]);
  const [selectedNft, setSelectedNft] = useState(null);
  const [stakingPeriod, setStakingPeriod] = useState(30);
  const [loading, setLoading] = useState(false);
  const [status, setStatus] = useState('');
  const [tokenStatus, setTokenStatus] = useState(null);
  const [showInitializer, setShowInitializer] = useState(false);

  // Enhanced Staking Dashboard state
  const [showDashboard, setShowDashboard] = useState(false);
  const [stakingData, setStakingData] = useState(null);
  const [dashboardLoading, setDashboardLoading] = useState(false);

  // 지갑이 연결되면 NFT 목록 가져오기
  useEffect(() => {
    if (wallet.connected) {
      fetchNfts();
      fetchStakingData(); // Also fetch staking data for the dashboard
    } else {
      setNfts([]);
      setSelectedNft(null);
      setStakingData(null);
    }
  }, [wallet.connected]);

  // NFT 목록 가져오기
  const fetchNfts = async () => {
    try {
      setLoading(true);
      setStatus('NFT 목록을 가져오는 중...');
      
      const response = await api.get(`/api/staking/getUserNFTs?wallet=${wallet.publicKey.toString()}`);
      
      if (response.data.success) {
        setNfts(response.data.data.nfts || []);
        setStatus(`${response.data.data.nfts?.length || 0}개의 NFT를 찾았습니다`);
        console.log('NFTs:', response.data.data.nfts);
      } else {
        setStatus('NFT 목록을 가져오는데 실패했습니다');
        console.error('NFT 가져오기 오류:', response.data.error);
      }
    } catch (error) {
      setStatus('NFT 목록을 가져오는데 실패했습니다');
      console.error('NFT 가져오기 오류:', error);
    } finally {
      setLoading(false);
    }
  };

  // 토큰 계정 초기화 확인
  const checkTokenAccount = async () => {
    if (!selectedNft) return;
    
    try {
      setTokenStatus('checking');
      setStatus('토큰 계정 상태 확인 중...');
      
      const response = await fetch("/api/staking/initializeTokenAccount", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          wallet: wallet.publicKey.toString(),
          mintAddress: selectedNft.mint
        }),
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || "토큰 계정 상태 확인 실패");
      }

      const data = await response.json();
      const needsInitialization = data.data.needsInitialization;

      if (needsInitialization) {
        setTokenStatus('needs_init');
        setStatus('토큰 계정 초기화가 필요합니다');
        setShowInitializer(true);
      } else {
        setTokenStatus('ready');
        setStatus('토큰 계정이 이미 초기화되어 있습니다. 스테이킹 준비 완료!');
      }
      
      return data.data;
    } catch (error) {
      console.error('토큰 계정 확인 오류:', error);
      setTokenStatus('error');
      setStatus(`토큰 계정 확인 오류: ${error.message}`);
      return null;
    }
  };

  // Fetch staking data for dashboard
  const fetchStakingData = async () => {
    if (!wallet.publicKey) return;

    try {
      setDashboardLoading(true);

      // Add cache-busting parameter to avoid caching issues
      const response = await fetch(`/api/staking/getStakingStats?wallet=${wallet.publicKey.toString()}&nocache=${Date.now()}`);

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || 'Failed to fetch staking data');
      }

      const data = await response.json();
      console.log('Staking dashboard data received:', data);

      setStakingData(data.data);
    } catch (error) {
      console.error('Error fetching staking dashboard data:', error);
      setStatus(`스테이킹 데이터 로드 오류: ${error.message}`);
    } finally {
      setDashboardLoading(false);
    }
  };

  // 스테이킹 실행
  const handleStaking = async () => {
    if (!selectedNft) return;

    try {
      setLoading(true);
      setStatus('스테이킹 준비 중...');
      
      // 토큰 계정 상태 확인
      if (tokenStatus !== 'ready') {
        const tokenResult = await checkTokenAccount();
        if (tokenStatus !== 'ready') {
          // 초기화가 필요하면 여기서 중단
          return;
        }
      }
      
      // 스테이킹 트랜잭션 준비
      const prepareResponse = await fetch("/api/staking/prepareStaking-anchor", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          wallet: wallet.publicKey.toString(),
          mintAddress: selectedNft.mint,
          stakingPeriod: stakingPeriod,
          nftTier: selectedNft.tier || 0,
          nftName: selectedNft.name
        }),
      });

      if (!prepareResponse.ok) {
        const errorData = await prepareResponse.json();
        throw new Error(errorData.error || "스테이킹 트랜잭션 준비 실패");
      }

      const prepareData = await prepareResponse.json();
      
      // 트랜잭션 서명
      setStatus('트랜잭션 서명 중...');
      const tx = Transaction.from(Buffer.from(prepareData.data.transactions.phase2, "base64"));
      const signedTx = await wallet.signTransaction(tx);
      
      // 트랜잭션 전송
      setStatus('트랜잭션 전송 중...');
      const signature = await connection.sendRawTransaction(signedTx.serialize());
      
      // 트랜잭션 확인
      setStatus('트랜잭션 확인 중...');
      await connection.confirmTransaction(signature);
      
      // 스테이킹 완료 기록
      setStatus('스테이킹 완료 기록 중...');
      const completeResponse = await fetch("/api/staking/completeStaking-anchor", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          signature,
          mintAddress: selectedNft.mint,
          stakingPeriod,
          walletAddress: wallet.publicKey.toString(),
          accounts: prepareData.data.accounts
        }),
      });

      if (!completeResponse.ok) {
        console.warn('스테이킹 완료 기록 실패, 하지만 온체인 트랜잭션은 성공함');
      }
      
      // 성공 처리
      setStatus(`스테이킹 성공! 트랜잭션: ${signature.slice(0, 8)}...`);
      fetchNfts(); // NFT 목록 갱신
      fetchStakingData(); // 대시보드 데이터 갱신
      setShowDashboard(true); // Show dashboard after successful staking
    } catch (error) {
      console.error('스테이킹 실패:', error);
      setStatus(`스테이킹 실패: ${error.message}`);
    } finally {
      setLoading(false);
    }
  };

  // 토큰 초기화 성공 처리
  const handleTokenInitSuccess = (data) => {
    console.log('토큰 초기화 성공:', data);
    setTokenStatus('ready');
    setShowInitializer(false);
    setStatus('토큰 계정 초기화 완료! 이제 스테이킹할 수 있습니다.');
  };

  // 토큰 초기화 오류 처리
  const handleTokenInitError = (error) => {
    console.error('토큰 초기화 오류:', error);
    setTokenStatus('error');
    setStatus(`토큰 초기화 오류: ${error.message}`);
    setShowInitializer(false);
  };

  return (
    <Layout>
      <div className="max-w-6xl mx-auto p-4">
        <h1 className="text-3xl font-bold mb-6">개선된 스테이킹 테스트</h1>

        <div className="mb-6">
          <h2 className="text-xl font-semibold mb-2">지갑 연결</h2>
          <WalletMultiButton />
          {wallet.connected && (
            <p className="mt-2">연결됨: {wallet.publicKey.toString().slice(0, 8)}...{wallet.publicKey.toString().slice(-8)}</p>
          )}
        </div>

        {wallet.connected && (
          <div className="mb-6">
            <div className="flex space-x-4 mb-4">
              <button
                onClick={() => setShowDashboard(false)}
                className={`px-4 py-2 rounded-lg font-medium transition-colors ${
                  !showDashboard ? 'bg-indigo-600 text-white' : 'bg-gray-200 text-gray-800 hover:bg-gray-300'
                }`}
              >
                스테이킹 설정
              </button>
              <button
                onClick={() => setShowDashboard(true)}
                className={`px-4 py-2 rounded-lg font-medium transition-colors ${
                  showDashboard ? 'bg-indigo-600 text-white' : 'bg-gray-200 text-gray-800 hover:bg-gray-300'
                }`}
              >
                스테이킹 대시보드
              </button>
              <button
                onClick={fetchStakingData}
                className="px-4 py-2 bg-green-600 text-white rounded-lg font-medium hover:bg-green-700 transition-colors"
                disabled={dashboardLoading}
              >
                {dashboardLoading ? '로딩 중...' : '새로고침'}
              </button>
            </div>
          </div>
        )}

        {/* Enhanced Staking Dashboard */}
        {wallet.connected && showDashboard && (
          <div className="mb-10">
            <h2 className="text-2xl font-bold mb-4">스테이킹 대시보드</h2>
            <EnhancedStakingDashboard
              stats={stakingData}
              isLoading={dashboardLoading}
              onRefresh={fetchStakingData}
            />
          </div>
        )}

        {wallet.connected && !showDashboard && (
          <>
            <div className="mb-6">
              <h2 className="text-xl font-semibold mb-2">NFT 선택</h2>
              {loading ? (
                <p>로딩 중...</p>
              ) : nfts.length > 0 ? (
                <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-4">
                  {nfts.map((nft) => (
                    <div
                      key={nft.mint}
                      className={`border p-3 rounded cursor-pointer ${
                        selectedNft?.mint === nft.mint ? 'border-blue-500 bg-blue-50' : 'border-gray-200'
                      }`}
                      onClick={() => {
                        setSelectedNft(nft);
                        setTokenStatus(null); // 새 NFT 선택시 토큰 상태 초기화
                      }}
                    >
                      <div className="w-full h-32 bg-gray-100 mb-2 flex items-center justify-center">
                        {nft.image ? (
                          <img
                            src={nft.image}
                            alt={nft.name}
                            className="max-w-full max-h-full object-contain"
                          />
                        ) : (
                          <div className="text-gray-400">이미지 없음</div>
                        )}
                      </div>
                      <div className="font-medium">{nft.name || `NFT #${nft.mint.slice(0, 6)}`}</div>
                      <div className="text-sm text-gray-500">{nft.mint.slice(0, 8)}...</div>
                    </div>
                  ))}
                </div>
              ) : (
                <p>NFT가 없습니다</p>
              )}
            </div>

            {selectedNft && (
              <div className="mb-6">
                <h2 className="text-xl font-semibold mb-2">스테이킹 기간 설정</h2>
                <div className="flex items-center">
                  <input
                    type="range"
                    min="7"
                    max="365"
                    value={stakingPeriod}
                    onChange={(e) => setStakingPeriod(parseInt(e.target.value))}
                    className="w-64 mr-4"
                  />
                  <span className="font-medium">{stakingPeriod}일</span>
                </div>
              </div>
            )}

            {selectedNft && (
              <div className="mb-6">
                <h2 className="text-xl font-semibold mb-2">토큰 계정 상태</h2>
                {tokenStatus === null ? (
                  <button
                    onClick={checkTokenAccount}
                    className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 transition-colors"
                    disabled={loading}
                  >
                    토큰 계정 상태 확인
                  </button>
                ) : tokenStatus === 'checking' ? (
                  <div className="flex items-center text-blue-500">
                    <svg className="animate-spin h-5 w-5 mr-2" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                      <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                      <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                    </svg>
                    확인 중...
                  </div>
                ) : tokenStatus === 'needs_init' ? (
                  <div className="text-yellow-500">
                    토큰 계정 초기화가 필요합니다
                  </div>
                ) : tokenStatus === 'ready' ? (
                  <div className="text-green-500">
                    ✓ 토큰 계정이 초기화되어 있습니다
                  </div>
                ) : (
                  <div className="text-red-500">
                    계정 상태 확인 중 오류가 발생했습니다
                  </div>
                )}
              </div>
            )}

            {selectedNft && (
              <div className="mb-6">
                <h2 className="text-xl font-semibold mb-2">스테이킹 실행</h2>
                <p className="mb-4">
                  <strong>{selectedNft.name || `NFT #${selectedNft.mint.slice(0, 6)}`}</strong>를{' '}
                  <strong>{stakingPeriod}일</strong> 동안 스테이킹합니다.
                </p>
                <button
                  onClick={handleStaking}
                  disabled={loading || tokenStatus !== 'ready'}
                  className="px-6 py-3 bg-indigo-600 hover:bg-indigo-700 text-white rounded-lg font-medium transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
                >
                  {loading ? (
                    <span className="flex items-center">
                      <svg className="animate-spin -ml-1 mr-2 h-5 w-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                        <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                        <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                      </svg>
                      처리 중...
                    </span>
                  ) : (
                    `스테이킹 실행 (${stakingPeriod}일)`
                  )}
                </button>
              </div>
            )}

            {status && (
              <div className="mt-4 p-3 bg-gray-50 border border-gray-200 rounded">
                <h3 className="font-semibold mb-1">상태:</h3>
                <p>{status}</p>
              </div>
            )}
          </>
        )}

        {/* Staking Data Debugging Information */}
        {wallet.connected && showDashboard && stakingData && (
          <div className="mt-8 bg-gray-800/50 p-4 rounded-xl border border-gray-700">
            <h3 className="text-xl font-semibold text-white mb-3">데이터 디버깅 정보</h3>
            <div className="overflow-auto max-h-96">
              <pre className="text-xs text-gray-400 font-mono">
                {JSON.stringify(stakingData.debug || {}, null, 2)}
              </pre>
            </div>
          </div>
        )}
      </div>

      {/* 토큰 계정 초기화 모달 */}
      {showInitializer && selectedNft && (
        <div className="fixed inset-0 flex items-center justify-center z-50 bg-black/70">
          <TokenAccountInitializer
            mintAddress={selectedNft.mint}
            onSuccess={handleTokenInitSuccess}
            onError={handleTokenInitError}
            onCancel={() => setShowInitializer(false)}
          />
        </div>
      )}
    </Layout>
  );
}